from django.test import TestCase
from django.db.utils import IntegrityError
from django.contrib.auth import get_user_model

from .models import (
    RecipeStep,
    Recipe,
    IndividualMeal,
    Group,
    GroupMeal
)

# Only recipe is tested because otherwise everything is just
# a Django model with default setup
class RecipeTest(TestCase):
    def setUp(self):
        super().setUp()
        Recipe.objects.create(name="Hamburger")

    def test_recipe_step_order(self):
        """
        Tests whether recipe prep is put in the order of the order field
        """
        ham = Recipe.objects.get(name="Hamburger")
        prep2 = RecipeStep.objects.create(step="Prep 2", order=2, recipe=ham)
        prep4 = RecipeStep.objects.create(step="Prep 4", order=4, recipe=ham)
        prep3 = RecipeStep.objects.create(step="Prep 3", order=3, recipe=ham)
        prep1 = RecipeStep.objects.create(step="Prep 1", order=1, recipe=ham)
        prep = ham.recipestep_set.all()
        self.assertEqual(prep[0], prep1)
        self.assertEqual(prep[1], prep2)
        self.assertEqual(prep[2], prep3)
        self.assertEqual(prep[3], prep4)
        
    def test_allow_multiple_blank_urls(self):
        """
        Tests that multiple recipes can have the same url if they are blank
        """
        ham = Recipe.objects.get(name="Hamburger")
        Recipe.objects.create(name="Lentil Soup")
        soup = Recipe.objects.get(name="Lentil Soup")
        self.assertIsNotNone(ham)
        self.assertIsNotNone(soup)

    def test_urls_unique_if_exist(self):
        """
        Tests that recipes cannot have the same url if they are not empty
        """
        test1 = Recipe.objects.create(name="Test Recipe1", url="https://www.google.com")
        with self.assertRaises(IntegrityError):
            test2 = Recipe.objects.create(name="Test Recipe2", url="https://www.google.com")
    
    def test_url_cannot_be_changed_on_update(self):
        """
        Tests that the recipe URL cannot be changed on update
        """
        test1 = Recipe.objects.create(name="Test Recipe 1", url="https://www.google.com")
        with self.assertRaises(IntegrityError):
            test1.url = "https://www.benyakiredits.com"
            test1.save()
    
    def test_recipe_can_be_saved_if_url_not_updated(self):
        """
        Tests that a recipe can be saved if its URL does not change
        """
        test1 = Recipe.objects.create(name="Test Recipe 1", url="https://www.google.com")
        test1.name="Test Recipe 1 Updated"
        test1.save()
        self.assertIsNotNone(test1)

        test2 = Recipe.objects.create(name="Test Recipe 2")
        test2.name="Test Recipe 2 Updated"
        test2.save()
        self.assertIsNotNone(test2)
        

    # Though this test should be in another class, this way we can piggy back tests off
    # already existing recipes without rewriting them
    def test_step_order_cannot_save_if_two_are_the_same(self):
        """
        Tests that recipes cannot have two steps that hav ehte same order
        """
        ham = Recipe.objects.get(name="Hamburger")
        RecipeStep.objects.create(order=1, step="Test Step 1", recipe=ham)
        with self.assertRaises(IntegrityError):
            RecipeStep.objects.create(order=1, step="Test Step 2", recipe=ham)
    
    def test_step_order_positive_integer_over_one(self):
        """
        Tests that recipe step order is an integer >= 1
        """
        ham = Recipe.objects.get(name="Hamburger")
        with self.assertRaises(IntegrityError):
            RecipeStep.objects.create(order=1.5, step="Test Step 1", recipe=ham)
        with self.assertRaises(IntegrityError):
            RecipeStep.objects.create(order=0, step="Test Step 2", recipe=ham)
        with self.assertRaises(IntegrityError):
            RecipeStep.objects.create(order=-1, step="Test Step 3", recipe=ham)
    
    def test_step_order_autogenerated_in_order(self):
        """
        Tests that if the step order is autogenerated
        then the steps will come in the correct order
        """
        ham = Recipe.objects.get(name="Hamburger")
        
        step1 = RecipeStep.objects.create(step="Test Step 1", recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 1)
        self.assertEqual(steps[0].order, 1)

        step2 = RecipeStep.objects.create(step="Test Step 2", recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 2)
        self.assertEqual(steps[1].order, 2)

        step3 = RecipeStep.objects.create(step="Test Step 3", recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 3)
        self.assertEqual(steps[2].order, 3)
    
    def test_step_order_autogenerated_to_fill_in_gaps(self):
        """
        Tests that if there is a mix of autogenerated steps and defined steps
        with a deliberate order, then the 
        """
        ham = Recipe.objects.get(name="Hamburger")

        step2 = RecipeStep.objects.create(step="Test Step 2", recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 1)
        self.assertEqual(steps[0].order, 1)

        step1 = RecipeStep.objects.create(step="Test Step 1", recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 2)
        self.assertEqual(steps[0].order, 1)
        self.assertEqual(steps[1].order, 2)

        step5 = RecipeStep.objects.create(step="Test Step 5", order=5, recipe=ham)
        step7 = RecipeStep.objects.create(step="Test Step 7", order=7, recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 4)
        self.assertEqual(steps[2].order, 5)
        self.assertEqual(steps[3].order, 7)

        step3 = RecipeStep.objects.create(step="Test Step 3", recipe=ham)
        step4 = RecipeStep.objects.create(step="Test Step 4", recipe=ham)
        step6 = RecipeStep.objects.create(step="Test Step 6", recipe=ham)
        steps = RecipeStep.objects.filter(recipe=ham)
        self.assertEqual(len(steps), 7)
        self.assertEqual(steps[2].order, 3)
        self.assertEqual(steps[3].order, 4)
        self.assertEqual(steps[4].order, 5)
        self.assertEqual(steps[5].order, 6)
        self.assertEqual(steps[6].order, 7)

class GroupTest(TestCase):
    def setUp(self):
        super().setUp()
        Group.objects.create(name="Test Group")
    
    def test_meal_time_day_unique(self):
        group = Group.objects.get(name="Test Group")
        GroupMeal.objects.create(time="B", day="MON", text="Test Meal 1", group=group)
        with self.assertRaises(IntegrityError):
            GroupMeal.objects.create(time="B", day="MON", text="Test Meal 2", group=group)
    
    def test_meal_time_day_allowed_if_not_duplicate(self):
        group = Group.objects.get(name="Test Group")
        meal1 = GroupMeal.objects.create(time="B", day="MON", text="Test Meal 1", group=group)
        meal2 = GroupMeal.objects.create(time="B", day="TUE", text="Test Meal 2", group=group)
        meal3 = GroupMeal.objects.create(time="L", day="MON", text="Test Meal 3", group=group)

        self.assertIsNotNone(group)
        self.assertIsNotNone(meal1)
        self.assertIsNotNone(meal2)
        self.assertIsNotNone(meal3)

class IndividualTest(TestCase):
    def setUp(self):
        super().setUp()
        get_user_model().objects.create_user(username="Test User", email="test@test.com", password="averytestpassword")
    
    def test_meal_time_day_unique(self):
        individual = get_user_model().objects.get(email="test@test.com").individual
        IndividualMeal.objects.create(time="B", day="MON", text="Test Meal 1", individual=individual)
        with self.assertRaises(IntegrityError):
            IndividualMeal.objects.create(time="B", day="MON", text="Test Meal 2", individual=individual)

    def test_meal_time_day_allowed_if_not_duplicate(self):
        individual = get_user_model().objects.get(email="test@test.com").individual
        meal1 = IndividualMeal.objects.create(time="B", day="MON", text="Test Meal 1", individual=individual)
        meal2 = IndividualMeal.objects.create(time="B", day="TUE", text="Test Meal 2", individual=individual)
        meal3 = IndividualMeal.objects.create(time="L", day="MON", text="Test Meal 3", individual=individual)

        self.assertIsNotNone(individual)
        self.assertIsNotNone(meal1)
        self.assertIsNotNone(meal2)
        self.assertIsNotNone(meal3)

# User is tested because it is separate from Individual
class UserTest(TestCase):
    def setUp(self):
        super().setUp()
        get_user_model().objects.create_user(username="Test User", email="test@test.com", password="averytestpassword")
    
    def test_corresponding_individual(self):
        """
        Tests that an individual is created when a new user is instantiated
        cf signals.py
        """
        test_user = get_user_model().objects.get(email="test@test.com")

        individual = test_user.individual
        self.assertIsNotNone(individual)

    def test_individual_no_shopping_list(self):
        """
        Tests that the new individual has a blank shopping list
        """
        test_user = get_user_model().objects.get(email="test@test.com")
        shopping_list = test_user.individual.individualshoppingitem_set.all()
        self.assertEqual(len(shopping_list), 0)
    
    def test_individual_no_meals(self):
        """
        Tests that the new individual has a blank meal set
        """
        test_user = get_user_model().objects.get(email="test@test.com")
        meals = test_user.individual.individualmeal_set.all()
        self.assertEqual(len(meals), 0)
        